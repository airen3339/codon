_ANCHOR_NONE  = 0
_ANCHOR_START = 1
_ANCHOR_BOTH  = 2

@tuple
class Span:
    start: int
    end: int

    def __bool__(self):
        return not (self.start == -1 and self.end == -1)

@C
@nocapture
def seq_re_match(re: cobj,
                 anchor: int,
                 string: str,
                 pos: int,
                 endpos: int) -> Ptr[Span]:
    pass

@C
@nocapture
def seq_re_match_one(re: cobj,
                     anchor: int,
                     string: str,
                     pos: int,
                     endpos: int,
                     span: Ptr[Span]) -> void:
    pass

@C
@pure
def seq_re_pattern_groups(re: cobj) -> int:
    pass

@C
@pure
def seq_re_group_name_to_index(re: cobj, name: str) -> int:
    pass

@C
@nocapture
def seq_re_pattern_groupindex(re: cobj,
                              names: Ptr[Ptr[str]],
                              indices: Ptr[Ptr[int]]) -> int:
    pass

@C
@nocapture
def seq_re_check_rewrite_string(re: cobj,
                                rewrite: str,
                                error: Ptr[str]) -> bool:
    pass

@C
@pure
def seq_re_escape(pattern: str) -> str:
    pass

@C
def seq_re_purge() -> void:
    pass

@C
def seq_re_compile(pattern: str, flags: int) -> cobj:
    pass

class error:
    _hdr: ExcHeader

    def __init__(self):
        self._hdr = ("re.error", "", "", "", 0, 0)

    def __init__(self, message: str):
        self._hdr = ("re.error", message, "", "", 0, 0)

    @property
    def message(self) -> str:
        return self._hdr.msg

    @property
    def msg(self):
        return self.message

@tuple
class Pattern:
    pattern: str
    flags: int
    _re: cobj

@tuple
class Match:
    _spans: Ptr[Span]
    pos: int
    endpos: int
    re: Pattern
    string: str

    def _get_group_int(self, g: int, n: int):
        if not (0 <= g <= n):
            raise IndexError("no such group")
        return self._spans[g]

    def _get_group_str(self, g: str, n: int):
        return self._get_group_int(seq_re_group_name_to_index(self.re._re, g), n)

    def _get_group(self, g, n: int):
        if isinstance(g, int):
            return self._get_group_int(g, n)
        elif isinstance(g, str):
            return self._get_group_str(g, n)
        else:
            compile_error("match group indices must be int or str")

    def _get_match(self, g, n: int):
        span = self._get_group(g, n)
        if not span:
            return ""
        return self.string._slice(span.start, span.end)

    def _group_multi(self, n: int, *args):
        if staticlen(args) == 1:
            return (self._get_match(args[0], n),)
        else:
            return (self._get_match(args[0], n), *self._group_multi(n, *args[1:]))

    def group(self, *args):
        if staticlen(args) == 0:
            return self._get_match(0, 1)
        elif staticlen(args) == 1:
            n = self.re.groups
            return self._get_match(args[0], n)
        else:
            n = self.re.groups
            return self._group_multi(n, *args)

    def __getitem__(self, g):
        return self._get_match(g, self.re.groups)

    def start(self, group = 0):
        return self._get_group(group, self.re.groups).start

    def end(self, group = 0):
        return self._get_group(group, self.re.groups).end

    def span(self, group = 0):
        start, end = self._get_group(group, self.re.groups)
        return start, end

@extend
class Pattern:
    @property
    def groups(self):
        return seq_re_pattern_groups(self._re)

    @property
    def groupindex(self):
        names = Ptr[str]()
        indices = Ptr[int]()
        n = seq_re_pattern_groupindex(self._re, __ptr__(names), __ptr__(indices))

        d = Dict[str, int](capacity=n)
        for i in range(n):
            d[names[i]] = indices[i]

        return d

    def _match_one(self, anchor: int, string: str, pos: Optional[int], endpos: Optional[int]):
        posx = 0 if pos is None else max(0, min(~pos, len(string)))
        endposx = len(string) if endpos is None else max(0, min(~endpos, len(string)))

        if posx > endposx:
            return None

        span = Span(-1, -1)
        seq_re_match_one(self._re, anchor, string, posx, endposx, __ptr__(span))
        if not span:
            return None

        spans = Ptr[Span](1)
        spans[0] = span
        return Match(spans, posx, endposx, self, string)

    def _match(self, anchor: int, string: str, pos: Optional[int], endpos: Optional[int]):
        posx = 0 if pos is None else max(0, min(~pos, len(string)))
        endposx = len(string) if endpos is None else max(0, min(~endpos, len(string)))

        if posx > endposx:
            return

        while True:
            spans = seq_re_match(self._re, anchor, string, posx, endposx)

            if not spans[0]:
                break

            yield Match(spans, posx, endposx, self, string)

            if posx == endposx:
                break

            elif posx == spans[0][1]:
                # We matched the empty string at pos and would be stuck, so in order
                # to make forward progress, increment the bytes offset.
                posx += 1
            else:
                posx = spans[0][1]

    def search(self, string: str, pos: Optional[int] = None, endpos: Optional[int] = None):
        return self._match_one(_ANCHOR_NONE, string, pos, endpos)

    def match(self, string: str, pos: Optional[int] = None, endpos: Optional[int] = None):
        return self._match_one(_ANCHOR_START, string, pos, endpos)

    def fullmatch(self, string: str, pos: Optional[int] = None, endpos: Optional[int] = None):
        return self._match_one(_ANCHOR_BOTH, string, pos, endpos)

    def finditer(self, string: str, pos: Optional[int] = None, endpos: Optional[int] = None):
        return self._match(_ANCHOR_NONE, string, pos, endpos)

    def findall(self, string: str, pos: Optional[int] = None, endpos: Optional[int] = None):
        return [m.group() for m in self.finditer(string, pos, endpos)]

    def _split(self, cb, string: str, maxsplit: int = 0):
        if maxsplit < 0:
            return [string], 0

        pieces = []
        end = 0
        numsplit = 0
        for match in self.finditer(string):
            if (maxsplit > 0 and numsplit >= maxsplit):
                break
            pieces.append(string[end:match.start()])
            pieces.extend(cb(match))
            end = match.end()
            numsplit += 1
        pieces.append(string[end:])
        return pieces, numsplit

    def split(self, string: str, maxsplit: int = 0):
        cb = lambda match: [match[group] for group in range(1, self.groups + 1)]
        pieces, _ = self._split(cb, string, maxsplit)
        return pieces

    def _repl(match, repl):
        if isinstance(repl, str):
            return match.expand(repl)
        else:
            return repl(match)

    def subn(self, repl, string: str, count: int = 0):
        cb = lambda match: [Pattern._repl(match, repl)]
        pieces, numsplit = self._split(cb, string, count)
        joined_pieces = ''.join(pieces)
        return joined_pieces, numsplit

    def sub(self, repl, string: str, count: int = 0):
        joined_pieces, _ = self.subn(repl, string, count)
        return joined_pieces

def compile(pattern: str, flags: int = 0):
    re = seq_re_compile(pattern, flags)
    return Pattern(pattern, flags, re)

def search(pattern: str, string: str, flags: int = 0):
    return compile(pattern, flags).search(string)

def match(pattern: str, string: str, flags: int = 0):
    return compile(pattern, flags).match(string)

def fullmatch(pattern: str, string: str, flags: int = 0):
    return compile(pattern, flags).fullmatch(string)

def finditer(pattern: str, string: str, flags: int = 0):
    return compile(pattern, flags).finditer(string)

def findall(pattern: str, string: str, flags: int = 0):
    return compile(pattern, flags).findall(string)

def split(pattern: str, string: str, maxsplit: int =0, flags: int = 0):
    return compile(pattern, flags).split(string, maxsplit)

def sub(pattern: str, repl, string: str, count: int =0, flags: int = 0):
    return compile(pattern, flags).sub(repl, string, count)

def subn(pattern: str, repl, string: str, count: int =0, flags: int = 0):
    return compile(pattern, flags).subn(repl, string, count)

def escape(pattern: str):
    return seq_re_escape(pattern)

def purge():
    seq_re_purge()
