# (c) 2022 Exaloop Inc. All rights reserved.

import os

from internal.dlopen import *

Py_DecRef = Function[[cobj], NoneType](cobj())
Py_IncRef = Function[[cobj], NoneType](cobj())
Py_Initialize = Function[[], NoneType](cobj())
PyBool_FromLong = Function[[int], cobj](cobj())
PyBytes_AsString = Function[[cobj], cobj](cobj())
PyDict_New = Function[[], cobj](cobj())
PyDict_Next = Function[[cobj, Ptr[int], Ptr[cobj], Ptr[cobj]], int](cobj())
PyDict_SetItem = Function[[cobj, cobj, cobj], cobj](cobj())
PyErr_Fetch = Function[[Ptr[cobj], Ptr[cobj], Ptr[cobj]], NoneType](cobj())
PyFloat_AsDouble = Function[[cobj], float](cobj())
PyFloat_FromDouble = Function[[float], cobj](cobj())
PyImport_AddModule = Function[[cobj], cobj](cobj())
PyImport_ImportModule = Function[[cobj], cobj](cobj())
PyIter_Next = Function[[cobj], cobj](cobj())
PyList_GetItem = Function[[cobj, int], cobj](cobj())
PyList_New = Function[[int], cobj](cobj())
PyList_SetItem = Function[[cobj, int, cobj], cobj](cobj())
PyLong_AsLong = Function[[cobj], int](cobj())
PyLong_FromLong = Function[[int], cobj](cobj())
PyObject_Call = Function[[cobj, cobj, cobj], cobj](cobj())
PyObject_GetAttr = Function[[cobj, cobj], cobj](cobj())
PyObject_GetAttrString = Function[[cobj, cobj], cobj](cobj())
PyObject_GetIter = Function[[cobj], cobj](cobj())
PyObject_HasAttrString = Function[[cobj, cobj], int](cobj())
PyObject_IsTrue = Function[[cobj], int](cobj())
PyObject_Length = Function[[cobj], int](cobj())
PyObject_SetAttrString = Function[[cobj, cobj, cobj], cobj](cobj())
PyObject_Str = Function[[cobj], cobj](cobj())
PyRun_SimpleString = Function[[cobj], NoneType](cobj())
PySet_Add = Function[[cobj, cobj], cobj](cobj())
PySet_New = Function[[cobj], cobj](cobj())
PyTuple_GetItem = Function[[cobj, int], cobj](cobj())
PyTuple_New = Function[[int], cobj](cobj())
PyTuple_SetItem = Function[[cobj, int, cobj], NoneType](cobj())
PyUnicode_AsEncodedString = Function[[cobj, cobj, cobj], cobj](cobj())
PyUnicode_DecodeFSDefaultAndSize = Function[[cobj, int], cobj](cobj())
PyUnicode_FromString = Function[[cobj], cobj](cobj())
Py_None = cobj()
Py_True = cobj()
Py_False = cobj()

_PY_MODULE_CACHE = Dict[str, pyobj]()

_PY_INIT = """
import io

clsf = None
clsa = None
plt = None
try:
    import matplotlib.figure
    import matplotlib.pyplot
    plt = matplotlib.pyplot
    clsf = matplotlib.figure.Figure
    clsa = matplotlib.artist.Artist
except ModuleNotFoundError:
    pass

def __codon_repr__(fig):
    if clsf and isinstance(fig, clsf):
        stream = io.StringIO()
        fig.savefig(stream, format="svg")
        return 'image/svg+xml', stream.getvalue()
    elif clsa and isinstance(fig, list) and all(
        isinstance(i, clsa) for i in fig
    ):
        stream = io.StringIO()
        plt.gcf().savefig(stream, format="svg")
        return 'image/svg+xml', stream.getvalue()
    elif hasattr(fig, "_repr_html_"):
        return 'text/html', fig._repr_html_()
    else:
        return 'text/plain', fig.__repr__()
"""

_PY_INITIALIZED = False


def init_dl_handles(py_handle: cobj):
    global Py_DecRef
    global Py_IncRef
    global Py_Initialize
    global PyBool_FromLong
    global PyBytes_AsString
    global PyDict_New
    global PyDict_Next
    global PyDict_SetItem
    global PyErr_Fetch
    global PyFloat_AsDouble
    global PyFloat_FromDouble
    global PyImport_AddModule
    global PyImport_ImportModule
    global PyIter_Next
    global PyList_GetItem
    global PyList_New
    global PyList_SetItem
    global PyLong_AsLong
    global PyLong_FromLong
    global PyObject_Call
    global PyObject_GetAttr
    global PyObject_GetAttrString
    global PyObject_GetIter
    global PyObject_HasAttrString
    global PyObject_IsTrue
    global PyObject_Length
    global PyObject_SetAttrString
    global PyObject_Str
    global PyRun_SimpleString
    global PySet_Add
    global PySet_New
    global PyTuple_GetItem
    global PyTuple_New
    global PyTuple_SetItem
    global PyUnicode_AsEncodedString
    global PyUnicode_DecodeFSDefaultAndSize
    global PyUnicode_FromString
    global Py_None
    global Py_True
    global Py_False

    Py_DecRef = dlsym(py_handle, "Py_DecRef")
    Py_IncRef = dlsym(py_handle, "Py_IncRef")
    Py_Initialize = dlsym(py_handle, "Py_Initialize")
    PyBool_FromLong = dlsym(py_handle, "PyBool_FromLong")
    PyBytes_AsString = dlsym(py_handle, "PyBytes_AsString")
    PyDict_New = dlsym(py_handle, "PyDict_New")
    PyDict_Next = dlsym(py_handle, "PyDict_Next")
    PyDict_SetItem = dlsym(py_handle, "PyDict_SetItem")
    PyErr_Fetch = dlsym(py_handle, "PyErr_Fetch")
    PyFloat_AsDouble = dlsym(py_handle, "PyFloat_AsDouble")
    PyFloat_FromDouble = dlsym(py_handle, "PyFloat_FromDouble")
    PyImport_AddModule = dlsym(py_handle, "PyImport_AddModule")
    PyImport_ImportModule = dlsym(py_handle, "PyImport_ImportModule")
    PyIter_Next = dlsym(py_handle, "PyIter_Next")
    PyList_GetItem = dlsym(py_handle, "PyList_GetItem")
    PyList_New = dlsym(py_handle, "PyList_New")
    PyList_SetItem = dlsym(py_handle, "PyList_SetItem")
    PyLong_AsLong = dlsym(py_handle, "PyLong_AsLong")
    PyLong_FromLong = dlsym(py_handle, "PyLong_FromLong")
    PyObject_Call = dlsym(py_handle, "PyObject_Call")
    PyObject_GetAttr = dlsym(py_handle, "PyObject_GetAttr")
    PyObject_GetAttrString = dlsym(py_handle, "PyObject_GetAttrString")
    PyObject_GetIter = dlsym(py_handle, "PyObject_GetIter")
    PyObject_HasAttrString = dlsym(py_handle, "PyObject_HasAttrString")
    PyObject_IsTrue = dlsym(py_handle, "PyObject_IsTrue")
    PyObject_Length = dlsym(py_handle, "PyObject_Length")
    PyObject_SetAttrString = dlsym(py_handle, "PyObject_SetAttrString")
    PyObject_Str = dlsym(py_handle, "PyObject_Str")
    PyRun_SimpleString = dlsym(py_handle, "PyRun_SimpleString")
    PySet_Add = dlsym(py_handle, "PySet_Add")
    PySet_New = dlsym(py_handle, "PySet_New")
    PyTuple_GetItem = dlsym(py_handle, "PyTuple_GetItem")
    PyTuple_New = dlsym(py_handle, "PyTuple_New")
    PyTuple_SetItem = dlsym(py_handle, "PyTuple_SetItem")
    PyUnicode_AsEncodedString = dlsym(py_handle, "PyUnicode_AsEncodedString")
    PyUnicode_DecodeFSDefaultAndSize = dlsym(py_handle, "PyUnicode_DecodeFSDefaultAndSize")
    PyUnicode_FromString = dlsym(py_handle, "PyUnicode_FromString")

    Py_None = dlsym(py_handle, "_Py_NoneStruct")
    Py_True = dlsym(py_handle, "_Py_TrueStruct")
    Py_False = dlsym(py_handle, "_Py_FalseStruct")


def init(python_loaded: bool = False):
    global _PY_INITIALIZED
    if _PY_INITIALIZED:
        return

    py_handle = cobj()
    if python_loaded:
        py_handle = dlopen("", RTLD_LOCAL | RTLD_NOW)
    else:
        LD = os.getenv("CODON_PYTHON", default="libpython." + dlext())
        py_handle = dlopen(LD, RTLD_LOCAL | RTLD_NOW)

    init_dl_handles(py_handle)

    if not python_loaded:
        Py_Initialize()

    PyRun_SimpleString(_PY_INIT.c_str())
    _PY_INITIALIZED = True


def ensure_initialized(python_loaded: bool = False):
    if not _PY_INITIALIZED:
        init(python_loaded)


@extend
class pyobj:
    @__internal__
    def __new__() -> pyobj:
        pass

    def __raw__(self) -> Ptr[byte]:
        return __internal__.class_raw(self)

    def __init__(self, p: Ptr[byte], steal: bool = False):
        self.p = p
        if not steal:
            self.incref()

    def __del__(self):
        self.decref()

    def _getattr(self, name: str) -> pyobj:
        return pyobj(pyobj.exc_wrap(PyObject_GetAttrString(self.p, name.c_str())), steal=True)

    def __len__(self) -> int:
        return pyobj.exc_wrap(PyObject_Length(self.p))

    def __to_py__(self) -> cobj:
        return self.p

    def __from_py__(p: cobj) -> pyobj:
        return pyobj(p)

    def __str__(self) -> str:
        return str.__from_py__(self._getattr("__str__").__call__().p)

    def __repr__(self) -> str:
        return str.__from_py__(self._getattr("__repr__").__call__().p)

    def __iter__(self) -> Generator[pyobj]:
        it = PyObject_GetIter(self.p)
        if not it:
            raise ValueError("Python object is not iterable")
        while i := PyIter_Next(it):
            yield pyobj(pyobj.exc_wrap(i), steal=True)
        pyobj.decref(it)
        pyobj.exc_check()

    def to_str(p: cobj, errors: str, empty: str = "") -> str:
        obj = PyUnicode_AsEncodedString(p, "utf-8".c_str(), errors.c_str())
        if obj == cobj():
            return empty
        bts = PyBytes_AsString(obj)
        res = str.from_ptr(bts)
        pyobj.decref(obj)
        return res

    def to_str(self, errors: str, empty: str = "") -> str:
        return pyobj.to_str(self.p, errors, empty)

    def exc_check():
        ptype, pvalue, ptraceback = cobj(), cobj(), cobj()
        PyErr_Fetch(__ptr__(ptype), __ptr__(pvalue), __ptr__(ptraceback))
        if ptype != cobj():
            py_msg = PyObject_Str(pvalue) if pvalue != cobj() else pvalue
            msg = pyobj.to_str(py_msg, "ignore", "<empty Python message>")
            py_typ = PyObject_GetAttrString(ptype, "__name__".c_str())
            typ = pyobj.to_str(py_typ, "ignore")

            pyobj.decref(ptype)
            pyobj.decref(pvalue)
            pyobj.decref(ptraceback)
            pyobj.decref(py_msg)
            pyobj.decref(py_typ)

            raise PyError(msg, typ)

    def exc_wrap(_retval: T, T: type) -> T:
        pyobj.exc_check()
        return _retval

    def incref(self):
        Py_IncRef(self.p)
        return self

    def incref(ptr: Ptr[byte]):
        Py_IncRef(ptr)

    def decref(self):
        Py_DecRef(self.p)
        return self

    def decref(ptr: Ptr[byte]):
        Py_DecRef(ptr)

    def __call__(self, *args, **kwargs):
        args_py = args.__to_py__()
        kws_py = cobj()
        if staticlen(kwargs) > 0:
            names = iter(kwargs.__dict__())
            kws = {next(names): pyobj(i.__to_py__(), steal=True) for i in kwargs}
            kws_py = kws.__to_py__()
        return pyobj(pyobj.exc_wrap(PyObject_Call(self.p, args_py, kws_py)), steal=True)

    def _tuple_new(length: int):
        return pyobj.exc_wrap(PyTuple_New(length))

    def _tuple_set(p: cobj, idx: int, val: cobj):
        PyTuple_SetItem(p, idx, val)
        pyobj.exc_check()

    def _tuple_get(p: cobj, idx: int) -> cobj:
        return pyobj.exc_wrap(PyTuple_GetItem(p, idx))

    def _import(name: str) -> pyobj:
        ensure_initialized()
        if name in _PY_MODULE_CACHE:
            return _PY_MODULE_CACHE[name]
        m = pyobj(pyobj.exc_wrap(PyImport_ImportModule(name.c_str())), steal=True)
        _PY_MODULE_CACHE[name] = m
        return m

    def _exec(code: str):
        ensure_initialized()
        PyRun_SimpleString(code.c_str())

    def _main_module() -> pyobj:
        return pyobj(pyobj.exc_wrap(PyImport_AddModule("__main__".c_str())))

    def _repr_mimebundle_(self, bundle=Set[str]()) -> Dict[str, str]:
        fn = pyobj._main_module()._getattr("__codon_repr__")
        assert fn.p != cobj(), "cannot find python.__codon_repr__"
        mime, txt = Tuple[str, str].__from_py__(fn.__call__(self).p)
        return {mime: txt}

    def __bool__(self):
        return bool.__from_py__(self._getattr("__bool__").__call__().p)


# Type conversions

@extend
class NoneType:
    def __to_py__(self) -> cobj:
        Py_IncRef(Py_None)
        return Py_None

    def __from_py__(i: cobj) -> None:
        return


@extend
class int:
    def __to_py__(self) -> cobj:
        return pyobj.exc_wrap(PyLong_FromLong(self))

    def __from_py__(i: cobj) -> int:
        return pyobj.exc_wrap(PyLong_AsLong(i))


@extend
class float:
    def __to_py__(self) -> cobj:
        return pyobj.exc_wrap(PyFloat_FromDouble(self))

    def __from_py__(d: cobj) -> float:
        return pyobj.exc_wrap(PyFloat_AsDouble(d))


@extend
class bool:
    def __to_py__(self) -> cobj:
        return pyobj.exc_wrap(PyBool_FromLong(int(self)))

    def __from_py__(b: cobj) -> bool:
        return pyobj.exc_wrap(PyObject_IsTrue(b)) != 0


@extend
class byte:
    def __to_py__(self) -> cobj:
        return str.__to_py__(str(__ptr__(self), 1))

    def __from_py__(c: cobj) -> byte:
        return str.__from_py__(c).ptr[0]


@extend
class str:
    def __to_py__(self) -> cobj:
        return pyobj.exc_wrap(PyUnicode_DecodeFSDefaultAndSize(self.ptr, self.len))

    def __from_py__(s: cobj) -> str:
        return pyobj.exc_wrap(pyobj.to_str(s, "strict"))


@extend
class List:
    def __to_py__(self) -> cobj:
        pylist = PyList_New(len(self))
        pyobj.exc_check()
        idx = 0
        for a in self:
            PyList_SetItem(pylist, idx, a.__to_py__())
            pyobj.exc_check()
            idx += 1
        return pylist

    def __from_py__(v: cobj) -> List[T]:
        n = pyobj.exc_wrap(PyObject_Length(v))
        t = List[T](n)
        for i in range(n):
            elem = PyList_GetItem(v, i)
            pyobj.exc_check()
            t.append(T.__from_py__(elem))
        return t


@extend
class Dict:
    def __to_py__(self) -> cobj:
        pydict = PyDict_New()
        pyobj.exc_check()
        for k, v in self.items():
            PyDict_SetItem(pydict, k.__to_py__(), v.__to_py__())
            pyobj.exc_check()
        return pydict

    def __from_py__(d: cobj) -> Dict[K, V]:
        b = dict[K, V]()
        pos = 0
        k_ptr = cobj()
        v_ptr = cobj()
        while PyDict_Next(d, __ptr__(pos), __ptr__(k_ptr), __ptr__(v_ptr)):
            pyobj.exc_check()
            k = K.__from_py__(k_ptr)
            v = V.__from_py__(v_ptr)
            b[k] = v
        return b


@extend
class Set:
    def __to_py__(self) -> cobj:
        pyset = PySet_New(cobj())
        pyobj.exc_check()
        for a in self:
            PySet_Add(pyset, a.__to_py__())
            pyobj.exc_check()
        return pyset

    def __from_py__(s: cobj) -> Set[K]:
        b = set[K]()
        s_iter = pyobj.exc_wrap(PyObject_GetIter(s))
        while True:
            k_ptr = pyobj.exc_wrap(PyIter_Next(s_iter))
            if not k_ptr:
                break
            k = K.__from_py__(k_ptr)
            pyobj.decref(k_ptr)
            b.add(k)
        pyobj.decref(s_iter)
        return b
