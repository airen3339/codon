# Copyright (C) 2022-2023 Exaloop Inc. <https://exaloop.io>

@tuple
@__internal__
class type[T]:
    #  __new__ / __init__: always done internally
    # __repr__
    # __call__
    # __name__
    # __module__
    # __doc__
    pass

@__internal__
class __internal__:
    pass
@__internal__
class __magic__:
    pass

@tuple
@__internal__
@__notuple__
class bool:
    pass

@tuple
@__internal__
@__notuple__
class byte:
    pass

@tuple
@__internal__
@__notuple__
class int:
    MAX = 9223372036854775807
    pass

@tuple
@__internal__
@__notuple__
class float:
    MIN_10_EXP = -307
    pass

@tuple
@__internal__
@__notuple__
class float32:
    MIN_10_EXP = -37
    pass

@tuple
@__internal__
class NoneType:
    pass

@tuple
@__internal__
@__notuple__
class Function[T, TR]:
    pass

@tuple
@__internal__
class Callable[T, TR]:
    pass

@tuple
@__internal__
@__notuple__
class Ptr[T]:
    pass
cobj = Ptr[byte]

@tuple
@__internal__
@__notuple__
class Generator[T]:
    pass

@tuple
@__internal__
@__notuple__
class Optional:
    T: type = NoneType

@tuple
@__internal__
@__notuple__
class Int[N: Static[int]]:
    pass

@tuple
@__internal__
@__notuple__
class UInt[N: Static[int]]:
    pass

@__internal__
class pyobj:
    p: Ptr[byte]

@tuple
@__internal__
class str:
    ptr: Ptr[byte]
    len: int

@tuple
@__internal__
class Array:
    len: int
    ptr: Ptr[T]
    T: type

@extend
class type:
    def __new__(obj):
        pass
function = Function

@__internal__
class Ref[T]:
    pass

@tuple
@__internal__
@__notuple__
class Union[TU]:
    # compiler-generated
    def __new__(val):
        TU

@extend
class Function:
    @llvm
    def __new__() -> Function[T, TR]:
        ret ptr null

# dummy
@__internal__
class TypeVar[T]: pass
@__internal__
class ByVal: pass
@__internal__
class ByRef: pass
@__internal__
class Tuple: pass

@__internal__
class ClassVar[T]:
    pass

@__internal__
class RTTI:
    id: int

@__internal__
@tuple
class ellipsis:
    @llvm
    def __new__() -> ellipsis:
        ret {} {}
Ellipsis = ellipsis()

@tuple
@__internal__
class __array__:
    T: type
    def __new__(sz: Static[int]) -> Array[T]:
        pass

@tuple
@__internal__
class Import:
    __ipath__: str
    __iname__: str
    P: Static[str]

    @llvm
    def __new__(path: str, name: str, P: Static[str]) -> Import[P]:
        %0 = insertvalue { {=str}, {=str} } undef, {=str} %path, 0
        %1 = insertvalue { {=str}, {=str} } %0,    {=str} %name, 1
        ret { {=str}, {=str} } %1

def __ptr__(var):
    pass

def staticlen(obj):
    pass

def compile_error(msg: Static[str]):
    pass

def isinstance(obj, what):
    pass

@__attribute__
def overload():
    pass

def hasattr(obj, attr: Static[str], *args, **kwargs):
    """Special handling"""
    pass

@overload
def hasattr(obj, attr: Static[str]):
    pass

def getattr(obj, attr: Static[str]):
    pass

def setattr(obj, attr: Static[str], what):
    pass

def tuple(iterable):
    pass

def super():
    pass

def superf(*args):
    """Special handling"""
    pass

def __realized__(fn, args):
    pass

def statictuple(*args):
    return args

def __has_rtti__(T: type):
    pass

#(init=False, repr=False, eq=False, order=False, hash=False, pickle=False, python=False, gpu=False, container=False)
@__internal__
@tuple
class NamedTuple:
    args: T
    N: Static[int]  # name cache ID
    T: type

    # todo)) nicer way to express type(())
    def __new__(args: T = (), T: type) -> NamedTuple[0, T]:
        return NamedTuple[0, T](())

    @llvm
    def __new__(args: T, N: Static[int], T: type) -> NamedTuple[N, T]:
        %0 = insertvalue { {=T} } undef, {=T} %args, 0
        ret { {=T} } %0

    def __getitem__(self, key: Static[str]):
        return getattr(self, key)

    def __keys__(self):
        return __internal__.namedkeys(N)

    def __repr__(self):
        keys = self.__keys__()
        values = [v.__repr__() for v in self.args]
        s = ', '.join(f"{keys[i]}: {values[i]}" for i in range(len(keys)))
        return f"({s})"


@__internal__
@tuple
class Partial:
    args: T  # format: (arg1, arg2, ..., (star_args...))
    kwargs: K

    F: Static[str] # function
    M: Static[str] # mask
    T: type # Tuple
    K: type # NamedTuple

    @llvm
    def __new__(args: T, kwargs: K, F: Static[str], M: Static[str], T: type, K: type) -> Partial[F, M, T, K]:
        %0 = insertvalue { {=T}, {=K} } undef, {=T} %args, 0
        %1 = insertvalue { {=T}, {=K} } %0, {=K} %kwargs, 1
        ret { {=T}, {=K} } %1

    def __repr__(self):
        return __magic__.repr_partial(self)
