# Copyright (C) 2022-2023 Exaloop Inc. <https://exaloop.io>

@tuple
class Slice[T, U, V]:
    start: T
    stop: U
    step: V

    def __new__(stop: U, U: type):
        start: Optional[int] = None
        step: Optional[int] = None
        return Slice(start, stop, step)

    def __new__(start: T, stop: U, T: type, U: type):
        step: Optional[int] = None
        return Slice(start, stop, step)

    def __new__(start: T, stop: U, step: V) -> Slice[T, U, V]:
        return (start, stop, step)

    def _ensure_int_or_none(self, method_name: str):
        if not (
                (T is int or T is Optional[int] or T is Optional[NoneType]) and
                (U is int or U is Optional[int] or U is Optional[NoneType]) and
                (V is int or V is Optional[int] or V is Optional[NoneType])
        ):
            raise TypeError(f"{method_name} requires all fields to be ints. Fields types are: "
                            f"start: {T.__name__}, stop: {U.__name__}, step: {V.__name__}")

    def adjust_indices(self, length: int) -> Tuple[int, int, int, int]:
        self._ensure_int_or_none("slice.adjust_indices")
        step: int = self.step if self.step is not None else 1
        start: int = 0
        stop: int = 0
        if step == 0:
            raise ValueError("slice step cannot be zero")
        if step > 0:
            start = self.start if isinstance(self.start, int) else 0
            stop = self.stop if isinstance(self.stop, int) else length
        else:
            start = self.start if isinstance(self.start, int) else length - 1
            stop = self.stop if isinstance(self.stop, int) else -(length + 1)

        return Slice.adjust_indices_helper(length, start, stop, step)

    def adjust_indices_helper(
        length: int, start: int, stop: int, step: int
    ) -> Tuple[int, int, int, int]:
        if start < 0:
            start += length
            if start < 0:
                start = -1 if step < 0 else 0
        elif start >= length:
            start = length - 1 if step < 0 else length

        if stop < 0:
            stop += length
            if stop < 0:
                stop = -1 if step < 0 else 0
        elif stop >= length:
            stop = length - 1 if step < 0 else length

        if step < 0:
            if stop < start:
                return start, stop, step, (start - stop - 1) // (-step) + 1
        else:
            if start < stop:
                return start, stop, step, (stop - start - 1) // step + 1

        return start, stop, step, 0

    def indices(self, length: int):
        if length < 0:
            raise ValueError("length should not be negative")
        return self.adjust_indices(length)[:-1]

    def __repr__(self):
        return f"slice({self.start}, {self.stop}, {self.step})"

    def __eq__(self, other):
        return self.start == other.start and self.step == other.step and self.stop == other.stop

    def __ne__(self, other):
        return not self.__eq__(other)

slice = Slice
