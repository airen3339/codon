# (c) 2022 Exaloop Inc. All rights reserved.

from internal.gc import sizeof as _sizeof

@tuple
class Device:
    _device: i32

    def __new__(device: int):
        from C import seq_nvptx_device(int) -> i32
        return Device(seq_nvptx_device(device))

    @staticmethod
    def count():
        from C import seq_nvptx_device_count() -> int
        return seq_nvptx_device_count()

    def __str__(self):
        from C import seq_nvptx_device_name(i32) -> str
        return seq_nvptx_device_name(self._device)

    def __index__(self):
        return int(self._device)

    def __bool__(self):
        return True

    @property
    def compute_capability(self):
        from C import seq_nvptx_device_capability(i32) -> int
        c = seq_nvptx_device_capability(self._device)
        return (c >> 32, c & 0xffffffff)

@tuple
class Memory[T]:
    _ptr: Ptr[byte]

    def _alloc(n: int, T: type):
        from C import seq_nvptx_device_alloc(int) -> Ptr[byte]
        return Memory[T](seq_nvptx_device_alloc(n * _sizeof(T)))

    def _read(self, p: Ptr[T], n: int):
        from C import seq_nvptx_memcpy_d2h(Ptr[byte], Ptr[byte], int)
        seq_nvptx_memcpy_d2h(p.as_byte(), self._ptr, n * _sizeof(T))

    def _write(self, p: Ptr[T], n: int):
        from C import seq_nvptx_memcpy_h2d(Ptr[byte], Ptr[byte], int)
        seq_nvptx_memcpy_h2d(self._ptr, p.as_byte(), n * _sizeof(T))

    def _free(self):
        from C import seq_nvptx_device_free(Ptr[byte])
        seq_nvptx_device_free(self._ptr)

@llvm
def syncthreads() -> None:
    declare void @llvm.nvvm.barrier0()
    call void @llvm.nvvm.barrier0()
    ret {} {}

@tuple
class Dim3:
    _x: u32
    _y: u32
    _z: u32

    def __new__(x: int, y: int, z: int):
        return Dim3(u32(x), u32(y), u32(z))

    @property
    def x(self):
        return int(self._x)

    @property
    def y(self):
        return int(self._y)

    @property
    def z(self):
        return int(self._z)

@tuple
class Thread:
    @property
    def x(self):
        @pure
        @llvm
        def get_x() -> u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.tid.x()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.tid.x()
            ret i32 %res

        return int(get_x())

    @property
    def y(self):
        @pure
        @llvm
        def get_y() -> u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.tid.y()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.tid.y()
            ret i32 %res

        return int(get_y())

    @property
    def z(self):
        @pure
        @llvm
        def get_z() -> u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.tid.z()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.tid.z()
            ret i32 %res

        return int(get_z())

@tuple
class Block:
    @property
    def x(self):
        @pure
        @llvm
        def get_x() -> u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.ctaid.x()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x()
            ret i32 %res

        return int(get_x())

    @property
    def y(self):
        @pure
        @llvm
        def get_y() -> u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.ctaid.y()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.y()
            ret i32 %res

        return int(get_y())

    @property
    def z(self):
        @pure
        @llvm
        def get_z() -> u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.ctaid.z()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.z()
            ret i32 %res

        return int(get_z())

    @property
    def dim(self):
        @pure
        @llvm
        def get_x() -> u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.ntid.x()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.ntid.x()
            ret i32 %res

        @pure
        @llvm
        def get_y() -> u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.ntid.y()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.ntid.y()
            ret i32 %res

        @pure
        @llvm
        def get_z() -> u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.ntid.z()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.ntid.z()
            ret i32 %res

        return Dim3(get_x(), get_y(), get_z())

@tuple
class Grid:
    @property
    def dim(self):
        @pure
        @llvm
        def get_x() -> u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.nctaid.x()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.nctaid.x()
            ret i32 %res

        @pure
        @llvm
        def get_y() -> u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.nctaid.y()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.nctaid.y()
            ret i32 %res

        @pure
        @llvm
        def get_z() -> u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.nctaid.z()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.nctaid.z()
            ret i32 %res

        return Dim3(get_x(), get_y(), get_z())

@tuple
class Warp:
    def __len__(self):
        @pure
        @llvm
        def get_warpsize() -> u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.warpsize()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.warpsize()
            ret i32 %res

        return int(get_warpsize())

thread = Thread()
block = Block()
grid = Grid()
warp = Warp()

def _tuple_from_gpu(args, gpu_args):
    if staticlen(args) > 0:
        a = args[0]
        g = gpu_args[0]
        a.__from_gpu__(g)
        _tuple_from_gpu(args[1:], gpu_args[1:])

def kernel(fn, *args):
    from C import seq_nvptx_function(str) -> cobj
    from C import seq_nvptx_invoke(cobj, u32, u32, u32, u32, u32, u32, u32, cobj)

    def canonical_dim(dim):
        if isinstance(dim, NoneType):
            return (1, 1, 1)
        elif isinstance(dim, int):
            return (dim, 1, 1)
        elif isinstance(dim, Tuple[int,int]):
            return (dim[0], dim[1], 1)
        elif isinstance(dim, Tuple[int,int,int]):
            return dim
        elif isinstance(dim, Dim3):
            return (dim.x, dim.y, dim.z)
        else:
            compile_error("bad dimension argument")

    def offsets(t):
        @pure
        @llvm
        def offsetof(t: T, i: Static[int], T: type, S: type) -> int:
            %p = getelementptr {=T}, {=T}* null, i64 0, i32 {=i}
            %s = ptrtoint {=S}* %p to i64
            ret i64 %s

        if staticlen(t) == 0:
            return ()
        else:
            T = type(t)
            S = type(t[-1])
            return (*offsets(t[:-1]), offsetof(t, staticlen(t) - 1, T, S))

    def wrapper(*args, grid, block):
        grid = canonical_dim(grid)
        block = canonical_dim(block)
        shared_mem = 0
        gpu_args = tuple(arg.__to_gpu__() for arg in args)
        kernel_ptr = seq_nvptx_function(__realized__(fn, gpu_args).__llvm_name__)
        p = __ptr__(gpu_args).as_byte()
        arg_ptrs = tuple((p + offset) for offset in offsets(gpu_args))
        seq_nvptx_invoke(kernel_ptr, u32(grid[0]), u32(grid[1]), u32(grid[2]), u32(block[0]),
                         u32(block[1]), u32(block[2]), u32(shared_mem), __ptr__(arg_ptrs).as_byte())
        _tuple_from_gpu(args, gpu_args)

    return wrapper

def _ptr_to_gpu(p: Ptr[T], n: int, T: type):
    mem = Memory._alloc(n, T)
    mem._write(p, n)
    return Ptr[T](mem._ptr)

def _ptr_from_gpu(p: Ptr[T], q: Ptr[T], n: int, T: type):
    mem = Memory[T](q.as_byte())
    mem._read(p, n)
    mem._free()

@pure
@llvm
def _ptr_to_type(p: cobj, T: type) -> T:
    ret i8* %p

@tuple
class Pointer[T]:
    _ptr: Ptr[T]
    _len: int

    def __to_gpu__(self):
        return _ptr_to_gpu(self._ptr, self._len)

    def __from_gpu__(self, other: Ptr[T]):
        _ptr_from_gpu(self._ptr, other, self._len)

@extend
class Ptr:
    def __to_gpu__(self):
        return self

    def __from_gpu__(self, other: Ptr[T]):
        pass

@extend
class NoneType:
    def __to_gpu__(self):
        return self

    def __from_gpu__(self, other: NoneType):
        pass

@extend
class int:
    def __to_gpu__(self):
        return self

    def __from_gpu__(self, other: int):
        pass

@extend
class float:
    def __to_gpu__(self):
        return self

    def __from_gpu__(self, other: float):
        pass

@extend
class float32:
    def __to_gpu__(self):
        return self

    def __from_gpu__(self, other: float32):
        pass

@extend
class bool:
    def __to_gpu__(self):
        return self

    def __from_gpu__(self, other: bool):
        pass

@extend
class byte:
    def __to_gpu__(self):
        return self

    def __from_gpu__(self, other: byte):
        pass

@extend
class Int:
    def __to_gpu__(self):
        return self

    def __from_gpu__(self, other: Int[N]):
        pass

@extend
class UInt:
    def __to_gpu__(self):
        return self

    def __from_gpu__(self, other: Int[N]):
        pass

@extend
class str:
    def __to_gpu__(self):
        n = self.len
        return str(_ptr_to_gpu(self.ptr, n), n)

    def __from_gpu__(self, other: str):
        Memory[byte](other.ptr)._free()

@extend
class List:
    def __to_gpu__(self):
        mem = List[T].__new__()
        cap = self.arr.len
        gpu_ptr = _ptr_to_gpu(self.arr.ptr, cap)
        mem.arr = Array[T](gpu_ptr, cap)
        mem.len = self.len

        s = tuple(mem)
        gpu_mem = Memory._alloc(1, type(s))
        gpu_mem._write(__ptr__(s), 1)
        return _ptr_to_type(gpu_mem._ptr, List[T])

    def __from_gpu__(self, other: List[T]):
        S = type(tuple(self))
        mem = List[T].__new__()
        _ptr_from_gpu(Ptr[S](mem.__raw__()), Ptr[S](other.__raw__()), 1)

        my_cap = self.arr.len
        other_cap = mem.arr.len

        if other_cap > my_cap:
            self._resize(other_cap)

        _ptr_from_gpu(self.arr.ptr, mem.arr.ptr, mem.len)
        self.len = mem.len

@extend
class Dict:
    def __to_gpu__(self):
        from internal.khash import __ac_fsize
        mem = Dict[K,V].__new__()
        n = self._n_buckets
        f = __ac_fsize(n)

        mem._n_buckets = n
        mem._size = self._size
        mem._n_occupied = self._n_occupied
        mem._upper_bound = self._upper_bound
        mem._flags = _ptr_to_gpu(self._flags, f)
        mem._keys = _ptr_to_gpu(self._keys, n)
        mem._vals = _ptr_to_gpu(self._vals, n)

        s = tuple(mem)
        gpu_mem = Memory._alloc(1, type(s))
        gpu_mem._write(__ptr__(s), 1)
        return _ptr_to_type(gpu_mem._ptr, Dict[K,V])

    def __from_gpu__(self, other: Dict[K,V]):
        from internal.khash import __ac_fsize
        S = type(tuple(self))
        mem = Dict[K,V].__new__()
        _ptr_from_gpu(Ptr[S](mem.__raw__()), Ptr[S](other.__raw__()), 1)

        my_n = self._n_buckets
        n = mem._n_buckets
        f = __ac_fsize(n)

        if my_n != n:
            self._flags = Ptr[u32](f)
            self._keys = Ptr[K](n)
            self._vals = Ptr[V](n)

        _ptr_from_gpu(self._flags, mem._flags, f)
        _ptr_from_gpu(self._keys, mem._keys, n)
        _ptr_from_gpu(self._vals, mem._vals, n)

        self._n_buckets = n
        self._size = mem._size
        self._n_occupied = mem._n_occupied
        self._upper_bound = mem._upper_bound

@extend
class Set:
    def __to_gpu__(self):
        from internal.khash import __ac_fsize
        mem = Set[K].__new__()
        n = self._n_buckets
        f = __ac_fsize(n)

        mem._n_buckets = n
        mem._size = self._size
        mem._n_occupied = self._n_occupied
        mem._upper_bound = self._upper_bound
        mem._flags = _ptr_to_gpu(self._flags, f)
        mem._keys = _ptr_to_gpu(self._keys, n)

        s = tuple(mem)
        gpu_mem = Memory._alloc(1, type(s))
        gpu_mem._write(__ptr__(s), 1)
        return _ptr_to_type(gpu_mem._ptr, Set[K])

    def __from_gpu__(self, other: Set[K]):
        from internal.khash import __ac_fsize
        S = type(tuple(self))
        mem = Set[K].__new__()
        _ptr_from_gpu(Ptr[S](mem.__raw__()), Ptr[S](other.__raw__()), 1)

        my_n = self._n_buckets
        n = mem._n_buckets
        f = __ac_fsize(n)

        if my_n != n:
            self._flags = Ptr[u32](f)
            self._keys = Ptr[K](n)

        _ptr_from_gpu(self._flags, mem._flags, f)
        _ptr_from_gpu(self._keys, mem._keys, n)

        self._n_buckets = n
        self._size = mem._size
        self._n_occupied = mem._n_occupied
        self._upper_bound = mem._upper_bound

@extend
class Optional:
    def __to_gpu__(self):
        if self is None:
            return self
        else:
            return Optional[T](self.__val__().__to_gpu__())

    def __from_gpu__(self, other: Optional[T]):
        if self is not None and other is not None:
            self.__val__().__from_gpu__(other.__val__())

@extend
class __internal__:
    def class_to_gpu(self):
        if isinstance(self, Tuple):
            return (a.__to_gpu__() for a in self)
        else:
            T = type(self)
            S = type(tuple(self))
            gpu_mem = _ptr_to_gpu(Ptr[S](self.__raw__()), 1)
            gpu_mem[0] = tuple(self).__to_gpu__()
            return _ptr_to_type(gpu_mem.as_byte(), T)

    def class_from_gpu(self, other):
        if isinstance(self, Tuple):
            _tuple_from_gpu(self, other)
        else:
            T = type(self)
            S = type(tuple(self))
            mem = T.__new__()
            _ptr_from_gpu(Ptr[S](mem.__raw__()), Ptr[S](other.__raw__()), 1)
            tup = tuple(mem)
            Ptr[S](self.__raw__())[0] = tup
            tuple(self).__from_gpu__(tup)
